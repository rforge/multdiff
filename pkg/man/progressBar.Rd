% Generated by roxygen2 (4.0.1): do not edit by hand
\name{progressBar}
\alias{progressBar}
\title{Yet another progress bar}
\usage{
progressBar(N, initial = 0, char = "=", width = NA, totalBar = TRUE,
  file = "", pid = FALSE)
}
\arguments{
\item{N}{a \code{numeric}. The total number of iterations.}

\item{initial}{a \code{numeric}. The initial value of the counter.}

\item{char}{a \code{character}. The character used to draw the progress bar.}

\item{width}{a \code{numeric}. The line width used when printing the progress bar.
If \code{NA} (the default), it is \code{getOption("width") - 10L}.}

\item{totalBar}{a \code{logical}. Should the progress bar be drawn for the total progress. If \code{FALSE} only the
percent completion is reported.}

\item{file}{a \code{character}. The file name used for printing the progress bar. The default value, \code{""},
means \code{\link{stdout}}.}

\item{pid}{a \code{logical}. Should the progress for the individual processes, according to their pid,
be reported (default value \code{FALSE}). Only considered if \code{file != ""}. In this case,
the individual progress bars are written to \code{paste(file, "Pid", sep = "")}.}
}
\value{
An object of class \code{progressBar} containing two functions \code{up} and \code{kill}.
        Call \code{up()} to increment the counter and update the progress bar. Remember
        to call \code{kill()} after the progress bar is used to clean up.
}
\description{
A progress bar that uses files to store progress counters with the intention
that it can be used together with parallel computations.
}
\details{
This progress bar is based on \code{\link{txtProgressBar}}. However, instead of using
a local variable associated with the progress bar object to keep track of the progress, this progress
bar uses files to store the progress. The intention is that the progress bar works
even when computations are carried out in parallel. It works by setting the total number \code{N}
of iterations when creating the \code{progressBar} object. In each interation a
counter is incremented, and the progress bar is updated with the percentage of completion
as measured by the current value of the counter relative to \code{N}.

It has only been tested with \code{\link{mclapply}} from the \code{\link{parallel}} package.
Option \code{pid = TRUE} only gives meaningful results in this case when \code{mc.preschedule = TRUE}
for \code{mclapply} (which is the default).

With a huge number of interations and little work in each, the file IO can produce a serious overhead.
}
\examples{
pb <- progressBar(100)
for(i in 1:100) {
  Sys.sleep(0.1)
  pb$up()
}
pb$kill()  ## Remember this to clean up. Removes files and directories used.
rm(pb)

\dontrun{
pb <- progressBar(100)
library(parallel)
tmp <- mclapply(1:100, function(i) {
  Sys.sleep(0.1)
  pb$up()
  }
)
pb$kill()  ## Remember this to clean up. Removes files and directories used.
rm(pb)}
}

